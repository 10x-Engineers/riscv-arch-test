= RISC-V Compliance Tests =
RISC-V Foundation Compliance Task Group
Issue 1.6 Draft
:toc:
:icons: font
:numbered:
:source-highlighter: rouge

////
SPDX-License-Identifier: CC-BY-4.0

Document conventions:
- one line per paragraph (don't fill lines - this makes changes clearer)
- Wikipedia heading conventions (First word only capitalized)
- US spelling throughout.
- Run "make spell" before committing changes.
- Build the HTML and commit it with any changed source.
- Do not commit the PDF!
////

== Introduction
=== About

This document describes the RISC-V Compliance Testing framework which is used to test a RISC-V device's compliance  to the different RISC-V specifications.  It is made freely available under a Creative Commons Attribution 4.0 International license. See the file `COPYING.CC` in the top level directory for details.

* It explains the required structure of a test, the framework around the tests, the running of individual tests, and the suites of tests.

* It includes, as reference, details of the first suite of tests for the RV32I and their reference signatures.

* It explains how to set up different targets to run the tests.

* It is an expansion of the work carried out by Codasip in the second half of 2017.

=== Purpose of compliance tests

The goal of compliance tests is to check whether the processor under development meets the open RISC-V standards or not. It is considered as non-functional testing meaning that it doesn’t substitute for design verification. This can be interpreted as testing to check all important aspects of the specification but without focusing on details, for example, on all possible values of instruction operands or all combinations of possible registers.

The result that compliance tests provide to the user is an assurance that the specification has been interpreted correctly and the design under test (DUT) can be declared as RISC-V compliant.

=== Intended audience

This document is intended for design and verification engineers who wish to develop new compliance tests and also those who wish check if their implementation (simulation models, HDL models, etc.) of a RISC-V processor is compliant to the RISC-V specifications. [[_Toc463952678]][[_Toc463952679]]

=== Feedback

Comments on this document should be made through the RISC-V Compliance Task Group mailing list. Proposed changes may be submitted as git pull requests.

=== Contributors

This document has been created by the following people (in alphabetical order of surname).

[quote]
Jeremy Bennett, Mary Bennett, Simon Davidmann, Radek Hajek, Lee Moore, Milan Nostersky, Marcela Zachariasova.

=== Document history
[cols="<1,<2,<3,<4",options="header,pagewidth",]
|================================================================================
| _Revision_ | _Date_            | _Author_ | _Modification_
| 1.6 Draft  | 10 June 2018      |

Jeremy Bennett |

Tidy up areas that are flawed in HTML version.

| 1.5 Draft  |  8 June 2018      |

Jeremy Bennett |

General tidy up.

| 1.4 Draft  |  8 June 2018      |

Jeremy Bennett |

Added license preamble.

| 1.3 Draft  |  5 June 2018      |

Simon Davidmann |

Updated to reflect directory structure and trace macros.

| 1.2 Draft  |  3 June 2018      |

Jeremy Bennett |

Converted to AsciiDoc, cleaned up and restructured.

| 1.1 Draft  |  1 June 2018      |

Simon Davidmann
Lee Moore |

Revised format and expand to describe framework, usage of many tests groups,
and different Targets

|1.0         | 24 December 2018  |

Radek Hajek
Milan Nostersky
Marcela Zachariasova |

First version of the document.

|================================================================================

== Overall structure
=== The compliance test

At the heart of the testing infrastructure is the detailed compliance test.  This is the RISC-V assembler code that is executed on the processor and that provides results in a defined memory area (the _signature_).  The test should only use the minimum of instructions and only those absolutely necessary.  It should only use instructions and registers from the ISA instruction set on which it is targeted.

=== The Test Virtual Machine

The test runs in the context of a _Test Virtual Machine_ (TVM) as defined and available at https://github.com/riscv/riscv-tests. There will be a different TVM for each instruction subset and each profile.

=== The target environment

A specific target will need to be chosen and setup to run the Test. This can be an Instruction Set Simulator (ISS), full system simulator (emulator), HDL simulator, FPGA prototype, or a board/chip, etc.  The test runs in the context of a TVM and is set up to run on the specific target.  The _target environment_ controls the loading of the test plus TVM onto the target, configures the device if needed, controls the execution, and then extracts the signature.

=== The processor configuration (device configuration)

The RISC-V specification allows many optional instructions, registers, and other features.  Many targets have a fixed selection of these optional items which cannot be changed. For example, a chip is fixed in the mask.  A simulator on the other hand may implement all known options and will need to be constrained to have only the required options available.  There will need to be processor configuration for those target devices which need to be constrained to only reflect the features of the device being compliance tested. This is essential when writing compliance tests to ensure that only available options are used in the tests.

=== The test signature

The _test signature_ is defined as reference data written into memory during the execution of the test.  It should record values and results of the operation of the Test.

=== The test reference signature

The _test reference signature_ is the _test signature_ saved from an execution run of the RISC‑V _golden model_.  This is currently from a RISC-V ISS, but the intention is that the RISC-V Formal Model from the RISCV.org Formal Working Group will be used when it is complete, functional, and available.

=== The test suites

Tests are grouped into different functional test suites targeting the different subsets of the full RISC-V specifications.  There will be ISA and privilege suites.

Currently there is one test suite: the RV32I (developed by Codasip).

Test suites will be developed in this priority order:

[options="compact"]
* RV32I
* RV64I
* RV32IM
* RV64IM
* RV32IC
* RV64IC
* RV32IA
* RV64IA
* RV32IF
* RV64IF
* RV32ID
* RV64ID
* RV32E
* RV32EC
* RV32EA
* RV32EF
* RV32ED

This order is subject to ratification by the Compliance Task Group

=== The test framework

This works at several levels.  At the lowest level it runs a test with a TVM on a specific configured target device and compares the test’s output test signature against the test reference signature and reports if there is any difference. A difference indicates that the target has failed that specific compliance test.

The test framework allows different test suites to be run depending on the capabilities of the target

The test framework collates the results of all the Tests that comprise a Test Suite and reports the overall results.

== Developing new tests
=== Structure

* Clone directory structure of an existing test suite alongside the RV32I tree.

* This must include test and reference signature directories (`src` and `references`).

* Check the target environment setup files.

* Check the processor configuration files.

=== Process

This description assumes the use of a configurable simulator with good trace and debug capabilities.

* Work on one test at a time.

* Ensure that the processor configuration is set appropriately.

* Use the `RVTEST` macros (defined in `compliance_io.h`) to make it easy to see the details of a Test’s execution. There are macros for assertions (`RVTEST_IO_ASSERT_EQ`) and tracing (`RVTEST_IO_WRITE_STR`) which are empty on targets that can not implement them.

* Assuming you are developing the test on a simulator, use the simulator’s tracing capabilities, especially a register change mode to single step your test examining all changing registers etc. to ensure your test is stimulating what is intending.

* Make sure that the signature you generate at the end of the run shows adequate internal test state such that any checks do report as fails if wrong.

* When you are satisfied that the test does what is intended and that the test signature is correct, copy this into a test reference signature (in the references directory).

For a test suite to be complete it needs to have tests that exercise the full functionality of what it is intended to test. There are tools available to measure instruction and other resource coverage. These should be used to ensure that 100% of the intended instructions have been tested.

== Test framework

For running compliance tests, the Test Virtual Machine (TVM) “p” available at https://github.com/riscv/riscv-tests is utilized.

In addition to using the basic functionality of the TVM, the script for running compliance tests runs the test on the target and then performs comparison of the target’s generated test signature to the manually reviewed test reference signature.

See the chapter below for selecting and setting up the target (simulator, or hardware, etc.).

If using a target that requires the processor to be configured, see the chapter below on processor configuration.

You will also need to have a suitable compiler tool chain (GCC or LLVM) installed in your environment and available on your path.

Tests are run by commands in the top level `Makefile` which has targets for simulate and verify

[source,make]
----
RISCV_TARGET?=riscvOVPsim
RISCV_DEVICE?=rv32i

simulate:
        make RISCV_TARGET=$(RISCV_TARGET) \
             RISCV_DEVICE=$(RISCV_DEVICE) \
             RISCV_PREFIX=riscv64-unknown-elf- \
             run -C $(ISA)

verify:
        verify.sh
----

== Setting the target environment

The target environment needs setting up to allow the compliance tests to be run on the target.  This can be used while developing compliance test suites or it can be used with new targets to see if they correctly execute the compliance test suites and are compliant!

This chapter provides information on the currently available targets and includes a short tutorial on how to add a new target.

=== Imperas riscvOVPsim compliance simulator

For tracing the test the following  macros are defined in `riscv-target/riscvOVPsim/compliance_io.h`:

[source,make]
----
RVTEST_IO_INIT
RVTEST_IO_PUTC(_R)
RVTEST_IO_WRITE_STR(_STR)
RVTEST_IO_ASSERT_EQ(_R, _I)
----

An example of a test that uses the tracing macros is `riscv-test-suite/rv32i/ISA/src/I-IO.S`.

To configure the simulator for different target devices there needs to be a Makefile fragment in the `device` directory.

The Makefile fragment for RV32I is in `riscv-target/riscvOVPsim/device/rv32i`

In the top level Makefile there needs to be a selection for the target and device:
[source,make]
----
RISCV_TARGET?=riscvOVPsim
RISCV_DEVICE?=rv32i
----

Also in the top level Makefile, you will need to configure other variables like `GCC_BIN`, `OVP_BIN`, `PATH` etc...


=== Codasip ISA simulator

tbd

=== GNU CGEN ISS
==== Within GDB

tbd

==== Via GDB Remote Serial Protocol

tbd

=== Berkeley Spike ISA simulator
For spike the file `riscv-target/spike/compliance_io.h` has the trace macros defined as empty.  The Makefile fragment in `riscv-target/spike/device/rv32i` has the spike run command for the RV32I device.

=== SiFive Freedom Unleashed 540 board (tbd)

tbd

=== Verilator Verilog RI5CY RTL processor
==== With GDB Server

tbd

==== With testbench monitor

tbd

=== Adding a new Target

In this section, a short tutorial how to add a user target in the TVM is provided.

If you do not want to use the TVM at all, it is recommended to just take the tests and references and incorporate them into your testing environment.  The only requirement needed in this case is that there must be an option to dump the results from the target in the test environment so as the comparison to test reference signature is possible.

The following steps demonstrate an example in which a target was replaced by Codasip ISA simulator. In a similar way, any RISC-V ISA simulator or any RTL simulation model of the RISC-V processor can be connected.

* Redefine macros in `ISA/src/compliance_test.h` and `binary_coding/src/compliance_test.h`.
+
For example, to support Codasip ISA simulator as Target, it was necessary to redefine `RV_COMPLIANCE_HALT macro`, `RV_COMPLIANCE_DATA_BEGIN` macro and `RV_COMPLIANCE_DATA_END` macro in `ISA/compliance_test.h` in the following way:
+
[source,c]
----
#define RV_COMPLIANCE_HALT
        add     x31, x0, 1
        sw      x31, codasip_syscall, t0
----

* This means that on the address defined by `codasip_syscall`, the 1 value is stored and this is interpreted as `HALT` for the Codasip ISA simulator.
+
[source,c]
----
#define RV_COMPLIANCE_DATA_BEGIN
        .align  4;
        .global codasip_signature_start;
codasip_signature_start:
----
+
[source,c]
----
#define RV_COMPLIANCE_DATA_END
        .align  4;
        .global codasip_signature_end;
codasip_signature_end:
----

* The Codasip ISA simulator dumps data from the addresses bounded by labels `codasip_signature_start` and `codasip_signature_end` to `stdout`.  The dumped data represent the results of the tests.

* Modify Makefiles in `ISA/Makefile` and `binary_coding/Makefile`.  It is important to change tools that are evaluated and parameters that are passed to the tools.
+
For example, to support the Codasip ISA simulator as the device under test
(DUT), it was necessary to change `RISCV_SIM` from `spike` to
`codix_berkelium-ia-isimulator –r` and parameters for running the simulator
from `+signature=$(work_dir)/$<_signature.output` to `–info 5` plus handle
redirection to a file by `1>$(work_dir)/$<_signature.output`.

== Configuring the target device

This section is for how to specify which optional parts are being used

NOTE: This is primarily for simulators.

In the directory `riscv-target/*/device` there are directories that have Makefile fragments that configure the simulator to simulate only those parts of the RISC-V specification that is required for the specific target device being tested.

For example for the riscvOVPsim to be configured to be a RV32I
[source,make]
----
RUN_TARGET= \
        riscvOVPsim.exe --variant RV32I --program $(work_dir_isa)/$< \
            --signaturedump \
            --override riscvOVPsim/cpu/sigdump/SignatureFile=$(work_dir_isa)/$(*)_signature.output \
            --override riscvOVPsim/cpu/sigdump/ResultReg=3 \
            --override riscvOVPsim/cpu/simulateexceptions=T \
            --logfile $(work_dir_isa)/$@
----
[appendix]
== One ISA Test

A detailed description of one ISA test.

[quote]
Header file including `riscv-test.h` from TVM, but in case you are not using TVM, header files of _your_ test environment should be included.

[source,c]
----
#include "compliance_test.h"
----

[quote]
TVM selection.

[source,c]
----
# Test Virtual Machine (TVM) used by program.

RV_COMPLIANCE_RV32M
----

[quote]
Code region – ISA test is divided into several parts marked as "A", "B", "C", etc. These parts differentiate different logical tests.

[source,c]
----
# Test code region.
RV_COMPLIANCE_CODE_BEGIN
----

[quote]
"A" parts of this test focus on checking corner case values of the `ADD` instruction.  In particular, `0`, `1`, `-1`, `0x7FFFFFFF`, `0x80000000` with `0`, `1`, `-1`, `MIN`, `MAX` values.

[source,c]
----
# ---------------------------------------------------------------------
# Test part A1 - general test of value 0 with 0, 1, -1, MIN, MAX
# register values

        # Addresses for test data and results
        la      x1, test_A1_data
        la      x2, test_A1_res
        # Load testdata
        lw      x3, 0(x1)

        # Register initialization
        li      x4, 0
        li      x5, 1
        li      x6, -1
        li      x7, 0x7FFFFFFF
        li      x8, 0x80000000

        # Test
        add     x4, x3, x4
        add     x5, x3, x5
        add     x6, x3, x6
        add     x7, x3, x7
        add     x8, x3, x8

        # Store results
        sw      x3, 0(x2)
        sw      x4, 4(x2)
        sw      x5, 8(x2)
        sw      x6, 12(x2)
        sw      x7, 16(x2)
        sw      x8, 20(x2)

# ---------------------------------------------------------------------
# Test part A2 - general test of value 1 with 0, 1, -1, MIN, MAX
# register values

        <similar code to A1>

# ---------------------------------------------------------------------
# Test part A3 - general test of value -1 with 0, 1, -1, MIN, MAX
# register values

        <similar code to A1>

# ---------------------------------------------------------------------
# Test part A4 - general test of value 0x7FFFFFFF with 0, 1, -1, MIN,
# MAX register values

        <similar code to A1>

# ---------------------------------------------------------------------
# Test part A5 - general test of value 0x80000000 with 0, 1, -1, MIN,
# MAX register values

        <similar code to A1>
----

[quote]
"B" part of this test focuses on forwarding between instruction. It means that result of one instruction is immediately passed to another instruction

[source,c]
----
# ---------------------------------------------------------------------
# Test part B - testing forwarding between instructions

        # Addresses for test data and results
        la      x25, test_B_data
        la      x26, test_B_res

        # Load testdata
        lw      x28, 0(x25)

        # Register initialization
        li      x27, 0x1

        # Test
        add     x29, x28, x27
        add     x30, x29, x27
        add     x31, x30, x27
        add     x1, x31, x27
        add     x2, x1, x27
        add     x3, x2, x27

        # store results
        sw      x27, 0(x26)
        sw      x28, 4(x26)
        sw      x29, 8(x26)
        sw      x30, 12(x26)
        sw      x31, 16(x26)
        sw      x1, 20(x26)
        sw      x2, 24(x26)
        sw      x3, 28(x26)
----

[quote]
"C" part of this test focuses on writing to `x0`. This register is hardwired to `0` value so it cannot happen in any RISC-V implementation that it is overwritten.

[source,c]
----
# ---------------------------------------------------------------------
# Test part C - testing writing to x0

        # Addresses for test data and results
        la      x1, test_C_data
        la      x2 , test_C_res

        # Load testdata
        lw      x28, 0(x1)

        # Register initialization
        li      x27, 0xF7FF8818

        # Test
        add     x0, x28, x27

        # store results
        sw      x0, 0(x2)
----

[quote]
"D" part of this test focuses on forwarding through `x0`. This register is hardwired to `0` value, so temporary nonzero result cannot be passed to another instruction.

[source,c]
----
# ---------------------------------------------------------------------
# Test part D - testing forwarding throught x0

        # Addresses for test data and results
        la      x1, test_D_data
        la      x2, test_D_res

        # Load testdata
        lw      x28, 0(x1)

        # Register initialization
        li      x27, 0xF7FF8818

        # Test
        add     x0, x28, x27
        add     x5, x0, x0

        # store results
        sw      x0, 0(x2)
        sw      x5, 4(x2)
----

[quote]
"E" part of this test focuses on `ADD` with `x0`. The ADD instruction performs `MOVE` operation in that case.

[source,c]
----
# ---------------------------------------------------------------------
# Test part E - testing moving (add with x0)

        # Addresses for test data and results
        la      x1, test_E_data
        la      x2, test_E_res

        # Load testdata
        lw      x3, 0(x1)

        # Test
        add     x4, x3, x0
        add     x5, x4, x0
        add     x6, x0, x5
        add     x14, x6, x0
        add     x15, x14, x0
        add     x16, x15, x0
        add     x25, x0, x16
        add     x26, x0, x25
        add     x27, x26, x0

        # Store results
        sw      x4, 0(x2)
        sw      x26, 4(x2)
        sw      x27, 8(x2)
----

[quote]
Every test environment should implement `HALT` macro. When this macro is called, operation of DUT is stopped and comparison to the reference results can be performed.

[source,c]
----
# ---------------------------------------------------------------------
# HALT

RV_COMPLIANCE_HALT
RV_COMPLIANCE_CODE_END
----

[quote]
Addresses used for storing input data.

[source,c]
----
# Input data section.
        .data

test_A1_data:
        .word     0
test_A2_data:
        .word     1
test_A3_data:
        .word     -1
test_A4_data:
        .word     0x7FFFFFFF
test_A5_data:
        .word     0x80000000
test_B_data:
        .word     0x0000ABCD
test_C_data:
        .word     0x12345678
test_D_data:
        .word     0xFEDCBA98
test_E_data:
        .word     0x36925814
----

[quote]
Addresses used for storing results.

[source,c]
----
# Output data section.
RV_COMPLIANCE_DATA_BEGIN

test_A1_res:
        .fill     6, 4, -1
test_A2_res:
        .fill     6, 4, -1
test_A3_res:
        .fill     6, 4, -1
test_A4_res:
        .fill     6, 4, -1
test_A5_res:
        .fill     6, 4, -1
test_B_res:
        .fill     8, 4, -1
test_C_res:
        .fill     1, 4, -1
test_D_res:
        .fill     2, 4, -1
test_E_res:
        .fill     3, 4, -1

RV_COMPLIANCE_DATA_END
----

[appendix]
== Repository structure

The top level directory contains a `README.md` file giving an overview of the project, top level `Makefile`, `ChangeLog`, the `verify.sh` script and complete license files for the Creative Commons and BSD licenses used by the task group.  There are then four top level directories.

`doc`:: All the documentation for the project, written using _AsciiDoc_.

`riscv-target`:: Contains a further subdirectory for each target, within which are placed the `compliance_io.h` header for that target and a `device` directory for all the devices of that target.

`riscv-test-env`:: This contains headers common to all environments, and then a directory for each TVM variant, with `link.ld` linker script and `riscv_test.h` header.

`riscv-test-suite`:: This contains a subdirectory for each instruction set or instruction set extension.  Within each subdirectory the source code and reference output for each test are in the `ISA` directory.

Diagrammatically this is:

----
*riscv-compliance*
*+-- doc*
*| |-- design.adoc*             // This document
*|*
*+-- riscv-target*
*| +-- riscvOVPsim*             // target that can run the test suites
*| | +-- device*                // devices to be tested
*| | | +-- rv32i*               // simulator config for the specific device
*| | | | |-- Makefile.include*  // specific run command
*| | | +-- compliance_io.h*     // macro implementation for this target
*| | *
*| |*
*| +-- spike*                   // target that can run the test suites
*| | +-- device*                // devices to be tested
*| | | +-- rv32i*               // simulator config for the specific device
*| | | | |-- Makefile.include*  // specific run command
*| | | +-- compliance_io.h*     // macro implementation for this target
*| | *
*|*
*+-- riscv-test-env*            // TVM available at Foundation gitlab
*| |-- p*
*| *
*+-- riscv-test-suite*          // where the tests live
*| +-- rv32i*
*| |-- ISA*                     // tests dedicated to instructions behavior
*| | |-- references*            // reference results for ISA tests
*| | |-- src*                   // assembler tests
*| | |-- Makefile*
*| | +--Makefrag*               // list of tests
*| |*
*| *
*| +-- rv32m*                   // placeholder for more tests
*| |-- ISA*                     // tests dedicated to instructions behavior
*| | |-- references*            // reference results for ISA tests
*| | |-- src*                   // assembler tests
*| | |-- Makefile*
*| | +--Makefrag*               // list of tests
*| |*
*| *
*|*
*| +--LICENCE*
*+-- Makefile*                  // main makefile
*+-- verify.sh*                 // main verify script
----

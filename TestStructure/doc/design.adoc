= RISC-V Compliance Tests =
Jeremy Bennett <jeremy.bennett@embecosm.com>; Mary Bennett <mary.bennett@embecosm.com>; Simon Davidmann <simond@imperas.com>; Radek Hajek <hajek@codasip.com>; Lee Moore <moore@imperas.com>; Milan Nostersky <nostersky@codasip.com>; Marcela Zachariasova <zachariasova@codasip.com>
v1.2, 3 June 2018: Converted to AsciiDoc and restructured.
:toc:
:icons:
:numbered:
:source-highlighter: rouge

[cols="<1,<2,<3,<4",options="header,pagewidth",]
|================================================================================
| _Revision_ | _Date_            | _Author_ | _Modification_
| 1.3 Draft  |  5 June 2018      |

simond@imperas.com |

Update to reflect directory structure and trace macros.
| 1.2 Draft  |  3 June 2018      |

jeremy.bennett@embecosm.com |

Converted to AsciiDoc, cleaned up and restructured.

| 1.1 Draft  |  1 June 2018      |

simond@imperas.com
moore@imperas.com |

Revised format and expand to describe framework, usage of many tests groups,
and different Targets

|1.0         | 24 December 2018  |

hajek@codasip.com
nostersky@codasip.com
zachariasova@codasip.com |

First version of the document.

|================================================================================

[preface]
== Preface
=== About

This document describes the RISC-V Compliance Testing framework that is used to test a RISC-V device is compliant to the different RISC-V specifications.

* It explains the required structure of a test, the framework around the tests, the running of individual tests, and the suites of tests.

* It includes, as reference, details of the first suite of tests for the RV32I and their reference signatures.

* It explains how to set up different targets to run the tests.

* It is an expansion of the work done by Codasip in the second half of 2017.

=== Intended Audience

This document is intended for design and verification engineers who wish to develop new compliance tests and also those who wish check if their implementation (simulation models, HDL models, etc.) of a RISC-V processor is compliant to the RISC-V specifications. [[_Toc463952678]][[_Toc463952679]]

=== Feedback

Comments on this document should be made through the RISC-V Compliance Task Group mailing list. Proposed changes may be submitted as git pull requests.

== Introduction
=== Purpose of Compliance Tests

The goal of compliance tests is to check whether the processor under development meets the open RISC-V standards or not. It is considered as non-functional testing meaning that it doesn’t substitute for design verification. This can be interpreted as testing to check all important aspects of the specification but without focusing on details, for example, on all possible values of instruction operands or all combinations of possible registers.

The result that compliance tests provide to the user is an assurance that the specification has been interpreted correctly and the design under test (DUT) can be declared as RISC-V compliant.

== Overall structure
=== The compliance Test

At the heart of the testing infrastructure is the detailed compliance Test. This is the RISC-V assembler code that is executed on the processor and that provides results in a defined memory area (the Signature). The Test should only use the minimum of instructions and only those absolutely necessary. It should only use instructions and registers from the ISA instruction set that it is focused on.

=== The Test Virtual Machine

The Test runs in the context of a Test Virtual Machine as defined and available at https://github.com/riscv/riscv-tests. There will be a different TVM for each instruction subset and each profile.

=== The Target Environment

A specific target will need to be chosen and setup to run the Test. This can be an Instruction Set Simulator (ISS), full system simulator (emulator), HDL simulator, FPGA prototype, or a board/chip, etc. The Test runs in the context of a TVM and is setup to run on the specific target. The Target Environment controls the loading of the Test+TVM onto the Target, configures the device if needed, controls the execution, and then extracts the Signature.

=== The Processor Configuration (Device Configuration)

The RISC-V specification allows many optional instructions, registers, and other features. Many Targets have a fixed selection of these optional items which cannot be changed. For example, a chip is fixed in the mask. A simulator on the other hand may implement all known options and will need to be constrained to have only the required options available. There will need to be Processor Configuration for those Target Devices which need to be constrained to only reflect the features of the device being compliance tested. This is essential when writing compliance tests to ensure that only available options are used in the tests.

=== The Test Signature

The Test Signature is defined as reference data written into memory during the execution of the Test. It should record values and results of the operation of the Test.

=== The Test Reference Signature

The Test Reference Signature is the Test Signature saved from an execution run of the RISC‑V Golden Model. This is currently from a RISC-V ISS, but the intention is that the RISC-V Formal Model from the RISCV.org Formal Working Group will be used when it is complete, functional, and available.

=== The Test Suites

Tests are grouped into different functional Test Suites targeting the different subsets of the full RISC-V specifications. There will be ISA and privilege suites.

Currently there is one Test Suite: the RV32I (developed by Codasip).

Test Suites will be developed in this priority order: (tbd)

RV32I, RV32IM, RV32IC, RV32IA, RV32E, RV32IF, RV32ID

RV64I, …

=== The Test Framework

This works at several levels. At the lowest level it runs a Test with a TVM on a specific configured Target device and compares the Test’s output Test Signature against the Test Reference Signature and reports if there is any difference. A difference indicates that the Target has failed that specific compliance Test.

The Test Framework allows different Test Suites to be run depending on the capabilities of the Target

The Test Framework collates the results of all the Tests that comprise a Test Suite and reports the overall results.

== Developing New Tests
=== Structure

* Clone directory structure of an existing Test Suite alongside the RV32I tree.

* This must include Test and Reference Signature directories (src and references).

* Check the Target Environment setup files.

* Check the Processor Configuration files.

=== Process

This description assumes the use of a configurable simulator with good trace and debug capabilities.

* Work on one Test at a time.

* Ensure that the Processor configuration is set appropriately.

* Use the RVTEST macros (defined in compliance_io.h) to make it easy to see the details of a Test’s execution. There are macros for assertions (RVTEST_IO_ASSERT_EQ) and tracing (RVTEST_IO_WRITE_STR) which are null on Targets that can not implement them.

* Assuming you are developing the Test on a simulator, use the simulator’s tracing capabilities, especially a register change mode to single step your Test examining all changing registers etc. to ensure your test is stimulating what is intending.

* Make sure that the signature you generate at the end of the run shows adequate internal test state such that any checks do report as fails if wrong.

* When you are satisfied that the Test does what is intended and that the Test Signature is correct, copy this into a Test Reference Signature (in the references directory).

For a test suite to be complete it needs to have tests that exercise the full functionality of what it is intended to test. There are tools available to measure instruction and other resource coverage. These should be used to ensure that 100% of the intended instructions have been tested.

== Test Framework

For running compliance tests, Test Virtual Machine (TVM) “p” available at https://github.com/riscv/riscv-tests is utilized.

In addition to using the basic functionality of TVM, the script for running compliance tests runs the Test on the Target and then performs comparison of the Target’s generated Test Signature to the manually reviewed Test Reference Signature.

See the chapter below for selecting and setting up the Target (simulator, or hardware, etc.).

If using a Target that requires the processor to be configured, see the chapter below on processor configuration.

You will also need to have GCC software tools available and setup in you paths/environment.

Tests are run by commands in the top level Makefile which has targets for simulate and verify

[source,shell]
----
RISCV_TARGET?=riscvOVPsim
RISCV_DEVICE?=rv32i

simulate:
    make RISCV_TARGET=$(RISCV_TARGET) RISCV_DEVICE=$(RISCV_DEVICE) RISCV_PREFIX=riscv64-unknown-elf- run -C $(ISA)

verify:
    verify.sh
----

== Setting The Target Environment

The Target Environment needs setting up to allow the compliance tests to be run on that Target. This can be used while developing compliance test suites or it can be used with new Targets to see if they correctly execute the compliance test suites and are compliant!

This chapter provides information on the currently available Targets and includes a short tutorial on how to add a new Target.

=== Imperas riscvOVPsim Compliance Simulator
For tracing the test the macros are defined in:
    riscv-compliance/TestStructure/riscv-target/riscvOVPsim/compliance_io.h

- #define RVTEST_IO_INIT
- #define RVTEST_IO_PUTC(_R)
- #define RVTEST_IO_WRITE_STR(_STR)
- #define RVTEST_IO_ASSERT_EQ(_R, _I)


An example of a test that uses the tracing macros is:
    rv32i/ISA/src/I-IO.S

To configure the simulator for different Target Devices there needs to be a Makefile fragment in a 'device' directory.

The Makefile fragment for RV32I is in:
    riscv-compliance/TestStructure/riscv-target/riscvOVPsim/device/rv32i

And in the top level Makefile there needs to be a selection for the Target and Device:
    RISCV_TARGET?=riscvOVPsim
    RISCV_DEVICE?=rv32i

Also in the top level Makefile, you will need to configure other variables like GCC_BIN, OVP_BIN, PATH etc...


=== Codasip ISA Simulator

tbd

=== GNU CGEN
==== Within GDB

tbd

==== Via GDB Remote Serial Protocol

tbd

=== Berkeley Spike ISA Simulator
For spike the riscv-compliance/TestStructure/riscv-target/spike/compliance_io.h has the trace macros defined as null.
The Makefile fragment in riscv-compliance/TestStructure/riscv-target/spike/device/rv32i has the spike run command for the RV32I device.

=== SiFive Freedom Unleashed 540 board (tbd)

tbd

=== Verilator Verilog RI5CY RTL processor (tbd)
==== With GDB Server

tbd

==== With testbench monitor

tbd

=== Adding a new Target

In this section, a short tutorial how to add a user Target in TVM is provided.

If you do not want to use TVM at all, it is recommended to just take the tests and references and incorporate them into your testing environment. The only requirement needed in this case is that there must be an option to dump the results from the Target in the test environment so as the comparison to Test Reference Signature is possible.

The following steps demonstrate an example in which a Target was replaced by Codasip ISA simulator. In a similar way, any RISC-V ISA simulator can be connected or any RTL simulation model of the RISC-V processor can be connected.

* Redefining macros in `ISA/src/compliance_test.h` and `binary_coding/src/compliance_test.h`.
+
For example, to support Codasip ISA simulator as Target, it was necessary to redefine `RV_COMPLIANCE_HALT macro`, `RV_COMPLIANCE_DATA_BEGIN` macro and `RV_COMPLIANCE_DATA_END` macro in `ISA/compliance_test.h` in the following way:
+
[source,c]
----
#define RV_COMPLIANCE_HALT
        add     x31, x0, 1
        sw      x31, codasip_syscall, t0
----

* It means that on the address defined by _codasip_syscall_, the 1 value is stored and this is interpreted as `HALT` for Codasip ISA simulator.
+
[source,c]
----
#define RV_COMPLIANCE_DATA_BEGIN
        .align  4;
        .global codasip_signature_start;
codasip_signature_start:
----
+
[source,c]
----
#define RV_COMPLIANCE_DATA_END
        .align  4;
        .global codasip_signature_end;
codasip_signature_end:
----

* Codasip ISA simulator dumps data from the addresses bounded by labels codasip_signature_start and codasip_signature_end to stdout (dumped data represent results of the tests).

* Modifying Makefiles in `ISA/Makefile` and `binary_coding/Makefile`.  It is important to change tools that are evaluated and parameters that are passed to the tools.
+
For example, to support Codasip ISA simulator as DUT, it was necessary to change `RISCV_SIM` from `spike` to `codix_berkelium-ia-isimulator –r` and parameters for running the simulator from `+signature=$(work_dir)/$<_signature.output` to `–info 5` plus handle redirection to a file by `1>$(work_dir)/$<_signature.output`.

== Configuring the Target Device

This section is for how to specify which optional parts are being used… for simulators primarily…

In the directory riscv-compliance/TestStructure/riscv-target/*/device there are directories that have Makefile fragments that configuret he simulator to simulate only those parts of the riscv specification that is required for the specific Target Device being tested.

For example for the riscvOVPsim to be configured to be a RV32I
    RUN_TARGET=\
        riscvOVPsim.exe --variant RV32I --program $(work_dir_isa)/$< \
            --signaturedump \
            --override riscvOVPsim/cpu/sigdump/SignatureFile=$(work_dir_isa)/$(*)_signature.output \
            --override riscvOVPsim/cpu/sigdump/ResultReg=3 \
            --override riscvOVPsim/cpu/simulateexceptions=T \
            --logfile $(work_dir_isa)/$@

[appendix]
== One ISA Test

A detailed description of one ISA test.

[quote] Header file including `riscv-test.h` from TVM, but in case you are not using TVM, header files of _your_ test environment should be included.

[source,c]
----
#include "compliance_test.h"
----

[quote]
TVM selection.

[source,c]
----
# Test Virtual Machine (TVM) used by program.

RV_COMPLIANCE_RV32M
----

[quote] Code region – ISA test is divided into several parts marked as "A", "B", "C", etc. These parts differenciate different logical tests.

[source,c]
----
# Test code region.
RV_COMPLIANCE_CODE_BEGIN
----

[quote]
"A" parts of this test focus on checking corner case values of the `ADD` instruction.  In particular, `0`, `1`, `-1`, `0x7FFFFFFF`, `0x80000000` with `0`, `1`, `-1`, `MIN`, `MAX` values.

[source,c]
----
# ---------------------------------------------------------------------
# Test part A1 - general test of value 0 with 0, 1, -1, MIN, MAX
# register values

        # Addresses for test data and results
        la      x1, test_A1_data
        la      x2, test_A1_res
        # Load testdata
        lw      x3, 0(x1)

        # Register initialization
        li      x4, 0
        li      x5, 1
        li      x6, -1
        li      x7, 0x7FFFFFFF
        li      x8, 0x80000000

        # Test
        add     x4, x3, x4
        add     x5, x3, x5
        add     x6, x3, x6
        add     x7, x3, x7
        add     x8, x3, x8

        # Store results
        sw      x3, 0(x2)
        sw      x4, 4(x2)
        sw      x5, 8(x2)
        sw      x6, 12(x2)
        sw      x7, 16(x2)
        sw      x8, 20(x2)

# ---------------------------------------------------------------------
# Test part A2 - general test of value 1 with 0, 1, -1, MIN, MAX
# register values

        <similar code to A1>

# ---------------------------------------------------------------------
# Test part A3 - general test of value -1 with 0, 1, -1, MIN, MAX
# register values

        <similar code to A1>

# ---------------------------------------------------------------------
# Test part A4 - general test of value 0x7FFFFFFF with 0, 1, -1, MIN,
# MAX register values

        <similar code to A1>

# ---------------------------------------------------------------------
# Test part A5 - general test of value 0x80000000 with 0, 1, -1, MIN,
# MAX register values

        <similar code to A1>
----

[quote]
"B" part of this test focuses on forwarding between instruction. It means that result of one instruction is immediately passed to another instruction

[source,c]
----
# ---------------------------------------------------------------------
# Test part B - testing forwarding between instructions

        # Addresses for test data and results
        la      x25, test_B_data
        la      x26, test_B_res

        # Load testdata
        lw      x28, 0(x25)

        # Register initialization
        li      x27, 0x1

        # Test
        add     x29, x28, x27
        add     x30, x29, x27
        add     x31, x30, x27
        add     x1, x31, x27
        add     x2, x1, x27
        add     x3, x2, x27

        # store results
        sw      x27, 0(x26)
        sw      x28, 4(x26)
        sw      x29, 8(x26)
        sw      x30, 12(x26)
        sw      x31, 16(x26)
        sw      x1, 20(x26)
        sw      x2, 24(x26)
        sw      x3, 28(x26)
----

[quote]
"C" part of this test focuses on writing to `x0`. This register is hardwired to `0` value so it cannot happen in any RISC-V implementation that it is overwritten.

[source,c]
----
# ---------------------------------------------------------------------
# Test part C - testing writing to x0

        # Addresses for test data and results
        la      x1, test_C_data
        la      x2 , test_C_res

        # Load testdata
        lw      x28, 0(x1)

        # Register initialization
        li      x27, 0xF7FF8818

        # Test
        add     x0, x28, x27

        # store results
        sw      x0, 0(x2)
----

[quote]
"D" part of this test focuses on forwarding through `x0`. This register is hardwired to `0` value, so temporary nonzero result cannot be passed to another instruction.

[source,c]
----
# ---------------------------------------------------------------------
# Test part D - testing forwarding throught x0

        # Addresses for test data and results
        la      x1, test_D_data
        la      x2, test_D_res

        # Load testdata
        lw      x28, 0(x1)

        # Register initialization
        li      x27, 0xF7FF8818

        # Test
        add     x0, x28, x27
        add     x5, x0, x0

        # store results
        sw      x0, 0(x2)
        sw      x5, 4(x2)
----

[quote]
"E" part of this test focuses on `ADD` with `x0`. The ADD instruction performs `MOVE` operation in that case.

[source,c]
----
# ---------------------------------------------------------------------
# Test part E - testing moving (add with x0)

        # Addresses for test data and results
        la      x1, test_E_data
        la      x2, test_E_res

        # Load testdata
        lw      x3, 0(x1)

        # Test
        add     x4, x3, x0
        add     x5, x4, x0
        add     x6, x0, x5
        add     x14, x6, x0
        add     x15, x14, x0
        add     x16, x15, x0
        add     x25, x0, x16
        add     x26, x0, x25
        add     x27, x26, x0

        # Store results
        sw      x4, 0(x2)
        sw      x26, 4(x2)
        sw      x27, 8(x2)
----

[quote]
Every test environment should implement `HALT` macro. When this macro is called, operation of DUT is stopped and comparison to the reference results can be performed.

[source,c]
----
# ---------------------------------------------------------------------
# HALT

RV_COMPLIANCE_HALT
RV_COMPLIANCE_CODE_END
----

[quote]
Addresses used for storing input data.

[source,c]
----
# Input data section.
        .data

test_A1_data:
        .word     0
test_A2_data:
        .word     1
test_A3_data:
        .word     -1
test_A4_data:
        .word     0x7FFFFFFF
test_A5_data:
        .word     0x80000000
test_B_data:
        .word     0x0000ABCD
test_C_data:
        .word     0x12345678
test_D_data:
        .word     0xFEDCBA98
test_E_data:
        .word     0x36925814
----

[quote]
Addresses used for storing results.

[source,c]
----
# Output data section.
RV_COMPLIANCE_DATA_BEGIN

test_A1_res:
        .fill     6, 4, -1
test_A2_res:
        .fill     6, 4, -1
test_A3_res:
        .fill     6, 4, -1
test_A4_res:
        .fill     6, 4, -1
test_A5_res:
        .fill     6, 4, -1
test_B_res:
        .fill     8, 4, -1
test_C_res:
        .fill     1, 4, -1
test_D_res:
        .fill     2, 4, -1
test_E_res:
        .fill     3, 4, -1

RV_COMPLIANCE_DATA_END
----

[appendix]
== Directory Structure

The package contains compliance tests, reference signatures and documentation in the following hierarchy:

----
*compliance-tests*
*|-- rv32i*
*| |-- ISA*             // tests dedicated to instructions behavior
*| | |-- references*    // reference results for ISA tests
*| | |-- src*           // assembler tests
*| | |-- Makefile*
*| | +--Makefrag*       // list of tests
*| |*
*| +-- binary coding*   // tests dedicated to binary coding
*|  |-- references*     // reference results for BC tests
*|  |-- src*            // assembler tests
*|  |-- Makefile*
*|  +-- Makefrag*       // list of tests
*|*
*|-- riscv-test-env*    // TVM available at Foundation gitlab
*| |-- p*
*| +--LICENCE*
*|*
*|-- doc*
*| |-- design.adoc*     // This document
*| +-- legacy.adoc*     // Legacy content from CodaSip's earlier work
*|*
*+-- run_test.sh*       // main running script
